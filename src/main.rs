use clap::Parser;
use rodio::{Decoder, OutputStream, Sink};
use std::fs;
use std::fs::File;
use std::io::BufReader;

mod tts;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    // Token for Google Cloud API. Usually generated by running `gcloud auth print-access-token`
    #[arg(short, long)]
    token: String,
    // Name of the Google Cloud project
    #[arg(short, long)]
    project: String,
    // Language / Voice
    // https://cloud.google.com/text-to-speech/docs/voices
    #[arg(short, long, default_value = "en-US")]
    language: String,
    #[arg(short, long, default_value = "en-US-Studio-M")]
    voice: String,
    // Text to be spoken, also accepts stdin
    #[arg(short, long, default_value = "")]
    message: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut args = Args::parse();

    if args.message == "" {
        let mut lines = Vec::new();
        let mut line = String::new();
        while std::io::stdin().read_line(&mut line)? != 0 {
            let line = std::mem::take(&mut line);
            lines.push(line);
        }
        args.message = lines.join("");
    }

    let res = tts::runtts(
        &args.token,
        &args.project,
        &args.language,
        &args.voice,
        &args.message,
    );
    let path = res.await?;

    // Play sound with rodio
    let (_stream, stream_handle) = OutputStream::try_default().unwrap();
    let sink = Sink::try_new(&stream_handle).unwrap();

    let file = BufReader::new(File::open(&path).unwrap());
    let source = Decoder::new(file).unwrap();
    sink.append(source);
    sink.sleep_until_end();

    // Wait for a half second to make sure the sound finishes
    std::thread::sleep(std::time::Duration::from_millis(500));

    // Delete temp file
    fs::remove_file(path)?;

    Ok(())
}
